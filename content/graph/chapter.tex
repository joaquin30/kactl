\chapter{Graph}

\section{Fundamentals}
	\kactlimport{BellmanFord.h}
	\kactlimport{FloydWarshall.h}
	\kactlimport{TopoSort.h}

\section{Euler walk}
	\kactlimport{EulerWalk.h}

\section{Network flow}
	\kactlimport{PushRelabel.h}
	\kactlimport{MinCostMaxFlow.h}
	\kactlimport{Dinics.py}
	\kactlimport{EdmondsKarp.h}
	% \kactlimport{Dinic.h}
	\kactlimport{MinCut.h}
	\kactlimport{GlobalMinCut.h}

\section{Matching}
	\kactlimport{hopcroftKarp.h}
	\kactlimport{DFSMatching.h}
	\kactlimport{MinimumVertexCover.h}
	\kactlimport{WeightedMatching.h}
	\kactlimport{GeneralMatching.h}
	\kactlimport{StableMarriage.h}

\section{DFS algorithms}
	\kactlimport{SCC.h}
	\kactlimport{BiconnectedComponents.h}
	\kactlimport{2sat.h}

\section{Heuristics}
	\kactlimport{MaximalCliques.h}

\section{Trees}
	\kactlimport{TreePower.h}
	\kactlimport{LCA.h}
	\kactlimport{CompressTree.h}
	\kactlimport{HLD.h}
	\kactlimport{LinkCutTree.h}
	%\columnbreak
	\kactlimport{MatrixTree.h}
\section{Tree diameter}
	Given an unrooted tree the longest path between two nodes in the tree is the diameter. To find it do BFS from an arbitrary node and pick a node farthest away. Do BFS from this node and the size of the longest path is the diameter.
	%\columnbreak
